#include <vector>
#include <iostream>
#include <numeric>
#include <algorithm>
#include <utility>
#include <cassert>

class tinymp
{
	typedef unsigned int elem_type;
	typedef unsigned long long widen_type;
	std::vector<elem_type> v;
	bool nonneg;
	void normalize() {
		while(v.size() > 1 && v.back() == 0) v.pop_back();
		if(is_zero()) nonneg = true;
	}
	void addsub(const std::vector<elem_type> &ov, bool oneg) {
		if(nonneg == oneg) {
			if(ov.size() > v.size()) v.resize(ov.size());
			elem_type carry = 0;
			for(std::size_t i = 0; i < v.size(); ++i) {
				elem_type new_carry;
				if(std::numeric_limits<elem_type>::max() - ov[i] < v[i] + carry) {
					new_carry = 1;
				} else {
					new_carry = 0;
				}
				v[i] += ov[i] + carry;
				carry = new_carry;
			}
			if(carry) v.push_back(1);
		} else {
			bool sub = absless(ov);
			if(ov.size() > v.size()) v.resize(ov.size());
			const std::vector<elem_type> &lhs = sub ? ov : v;
			const std::vector<elem_type> &rhs = sub ? v : ov;
			// ensures v.size() == lhs.size() >= rhs.size()
			elem_type borrow = 0;
			for(std::size_t i = 0; i < v.size(); ++i) {
				elem_type new_borrow;
				if(lhs[i] < rhs[i] + borrow) {
					new_borrow = 1;
				} else {
					new_borrow = 0;
				}
				v[i] = lhs[i] - rhs[i] - borrow;
				borrow = new_borrow;
			}
			assert(borrow == 0);
			normalize();
			nonneg = sub ? oneg : nonneg;
		}
	}
	bool absless(const std::vector<elem_type> &ov) const {
		if(v.size() < ov.size()) return true;
		if(v.size() > ov.size()) return false;
		return std::lexicographical_compare(v.rbegin(), v.rend(), ov.rbegin(), ov.rend());
	}
	bool absgreater(const std::vector<elem_type> &ov) const {
		if(v.size() < ov.size()) return false;
		if(v.size() > ov.size()) return true;
		return std::lexicographical_compare(ov.rbegin(), ov.rend(), v.rbegin(), v.rend());
	}
	bool absequal(const std::vector<elem_type> &ov) const {
		if(v.size() != ov.size()) return false;
		return std::equal(v.begin(), v.end(), ov.begin());
	}
	bool is_zero() const {
		return v.size() == 1 && v[0] == 0;
	}
public:
	tinymp(elem_type val = 0): v(1, val),nonneg(true) {}
	tinymp& operator+=(const tinymp& other) {
		addsub(other.v, other.nonneg);
		return *this;
	}
	tinymp& operator-=(const tinymp& other) {
		if(!other.is_zero()) addsub(other.v, !other.nonneg);
		return *this;
	}
	std::pair<tinymp&, elem_type> div_(elem_type s) {
		widen_type unit = widen_type(1) << std::numeric_limits<elem_type>::digits;
		widen_type borrow = 0;
		for(std::size_t i = 0; i < v.size(); ++i) {
			auto temp = borrow * unit + v[v.size() - i - 1];
			v[v.size() - i - 1] = temp / s;
			borrow = temp % s;
		}
		normalize();
		return { *this, borrow };
	}
	std::pair<tinymp, elem_type> div(elem_type s) const {
		return tinymp(*this).div_(s);
	}
	tinymp& operator/=(elem_type s) {
		return div_(s).first;
	}
	tinymp& flip_() {
		if(v.size() != 1 || v[0] != 0) nonneg = !nonneg;
		return *this;
	}
	tinymp operator-() const {
		tinymp r(*this);
		return std::move(r.flip_());
	}
	bool absless(const tinymp &other) const {
		return absless(other.v);
	}
	bool absgreater(const tinymp &other) const {
		return absgreater(other.v);
	}
	bool absequal(const tinymp &other) const {
		return absequal(other.v);
	}
	friend tinymp operator+(tinymp v1, const tinymp &v2) {
		return std::move(v1 += v2);
	}
	friend tinymp operator-(tinymp v1, const tinymp &v2) {
		return std::move(v1 -= v2);
	}
	friend tinymp operator/(tinymp v, elem_type s) {
		return std::move(v /= s);
	}
	friend elem_type operator%(tinymp v, elem_type s) {
		return v.div_(s).second;
	}
	friend bool operator==(const tinymp &v1, const tinymp &v2) {
		if(v1.nonneg != v2.nonneg) return false;
		return v1.absequal(v2);
	}
	friend bool operator!=(const tinymp &v1, const tinymp &v2) {
		return !(v1 == v2);
	}
	friend bool operator<(const tinymp &v1, const tinymp &v2) {
		if(!v1.nonneg && v2.nonneg) return true;
		if(v1.nonneg && !v2.nonneg) return false;
		if(v1.nonneg) return v1.absless(v2);
		return v1.absgreater(v2);
	}
	friend bool operator>(const tinymp &v1, const tinymp &v2) {
		return v2 < v1;
	}
	friend bool operator<=(const tinymp &v1, const tinymp &v2) {
		return !(v2 < v1);
	}
	friend bool operator>=(const tinymp &v1, const tinymp &v2) {
		return !(v2 > v1);
	}
	friend std::ostream& operator<<(std::ostream &os, tinymp v) {
		std::string s;
		bool negative = !v.nonneg;
		if(v.is_zero()) s = "0";
		else while(!v.is_zero()) { auto t = v.div_(10); s.push_back(t.second + '0'); }
		std::reverse(s.begin(), s.end());
		if(negative) os << '-';
		os << s;
		return os;
	}
};

int main(void)
{
	std::cout << (tinymp(0xFFFFFFFFUL)+tinymp(0xFFFFFFFFUL)) << std::endl;
	std::cout << -tinymp(0xFFFFFFFFUL) << std::endl;
	std::cout << (tinymp()+(-tinymp(0xFFFFFFFFUL))) << std::endl;
	std::cout << (tinymp(0xFFFFFFFFUL)+(-tinymp(0xFFFFFFFFUL))) << std::endl;
	std::cout << (tinymp(0xFFFFFFFFUL)-tinymp(0xFFFFFFFFUL))- << std::endl;
	return 0;
}
